design_analysis_task:
  description: >
    CRITICAL: You MUST use the "Component Image Analyzer" tool FIRST to load the image at {design_path}.

    IMPORTANT: The image shows ONE UI COMPONENT (not a full page design).
    It could be: navbar, button, card, form, hero section, footer, sidebar, etc.

    Your job: Analyze THIS SINGLE COMPONENT and extract complete specifications.

    OUTPUT FORMAT: You MUST create a VALID JSON document with complete component specifications.
    This JSON will be used by downstream agents to generate HTML/CSS for this component automatically.

    REQUIRED JSON STRUCTURE (COMPACT):

    {
      "component": {
        "name": "navbar",
        "type": "navigation",
        "width": "100%",
        "height": "80px"
      },
      "colors": {
        "background": "#FFFFFF",
        "text": "#333333",
        "primary": "#0066FF",
        "secondary": "#6B7280"
      },
      "layout": {
        "display": "flex",
        "justify": "space-between",
        "align": "center",
        "padding": "24px 40px",
        "gap": "32px"
      },
      "elements": [
        {
          "type": "logo",
          "text": "Brand Name",
          "position": "left",
          "fontSize": "24px",
          "fontWeight": "700",
          "color": "#000000"
        },
        {
          "type": "nav",
          "position": "center",
          "items": [
            {"text": "Home", "href": "#home"},
            {"text": "About", "href": "#about"}
          ],
          "fontSize": "16px",
          "color": "#333333"
        },
        {
          "type": "button",
          "text": "Sign Up",
          "position": "right",
          "background": "#0066FF",
          "color": "#FFFFFF",
          "padding": "12px 24px",
          "borderRadius": "8px"
        }
      ]
    }

    CRITICAL RULES:
    1. **Keep it SHORT** - Only include visible properties, skip defaults
    2. **No redundancy** - Don't repeat information
    3. **Essential only** - Focus on what's needed to recreate component
    4. **Exact text** - Copy all text exactly as shown
    5. **Color accuracy** - Estimate hex codes carefully

    COMPACT OUTPUT RULES:

    1. **BREVITY**: Skip default values (transparent, none, auto, 0)
    2. **ESSENTIAL ONLY**: Include only what's visible and necessary
    3. **NO REPETITION**: Don't repeat parent properties in children
    4. **CAMELCASE KEYS**: Use fontSize not font_size (shorter JSON)
    5. **ARRAYS NOT OBJECTS**: Use arrays for similar items
    6. **EXACT TEXT**: Copy all visible text exactly
    7. **HEX ONLY**: Just hex codes, no RGB
    8. **NO HOVER DEFAULTS**: Only include hover if visibly different

  expected_output: >
    COMPACT JSON (design_analysis.json) with:

    - component: {name, type, width, height}
    - colors: {background, text, primary, secondary} - hex only
    - layout: {display, justify, align, padding, gap}
    - elements: [{type, text, position, fontSize, color, ...}] - only visible properties

    The JSON must be:
    - ‚úÖ Valid (parseable)
    - ‚úÖ Compact (no redundancy, skip defaults)
    - ‚úÖ Accurate (exact text/colors from image)
    - ‚úÖ Small (<5KB for simple components, <10KB for complex)
    - ‚úÖ camelCase keys (shorter)

    DO NOT include: hover states unless visible, default values, empty fields, verbose objects.
    DO NOT wrap in markdown. Pure JSON only.
  agent: visual_strategist

component_listing_task:
  description: >
    Based on the design analysis, create a professional component specification document in Markdown format.
    Review the design analysis report and identify the MOST IMPORTANT, VISIBLE components.

    OUTPUT FORMAT: Create a beautifully formatted Markdown document with professional structure.

    REQUIRED MARKDOWN STRUCTURE:

    # üß© Component Specification

    > **Project:** [From design analysis]
    > **Date:** [Current date]
    > **Total Components:** 2
    > **Created by:** UI Architect

    ---

    ## üìã Component Selection Strategy

    Based on the design analysis, the following components have been prioritized for implementation:

    ### Selection Criteria
    - ‚úÖ **Visibility:** High-impact, immediately visible components
    - ‚úÖ **Functionality:** Core user interaction elements
    - ‚úÖ **Priority:** Essential for MVP/initial launch
    - ‚úÖ **Complexity:** Manageable scope for quality implementation

    ---

    ## üéØ Selected Components

    ### Component 1: [component-name]

    **üì¶ Component Details**
    | Property | Value |
    |----------|-------|
    | **Filename** | `component-name.html` |
    | **Type** | Navigation / Section / Button / etc. |
    | **Priority** | HIGH |
    | **Complexity** | Low / Medium / High |

    **üé® Design Specifications**
    - **Colors:**
      - Background: `#HEX` (from design analysis)
      - Text: `#HEX`
      - Accent: `#HEX`
    - **Typography:**
      - Font: [Font name from analysis]
      - Size: [Size from analysis]
      - Weight: [Weight from analysis]
    - **Spacing:**
      - Padding: [Values from analysis]
      - Margin: [Values from analysis]
      - Height: [Height from analysis]

    **üîß Key Features**
    - Feature 1: [Description]
    - Feature 2: [Description]
    - Feature 3: [Description]

    **üìê Layout Structure**
    ```
    [Describe layout: e.g., "Logo (left) | Nav Links (center) | CTA Button (right)"]
    ```

    **üé≠ Interactive Elements**
    - Hover states: [Description]
    - Click actions: [Description]
    - Responsive behavior: [Description]

    **üìù Content Requirements**
    - Text content: [Exact text from design]
    - Images: [Image requirements]
    - Icons: [Icon requirements]

    ---

    ### Component 2: [component-name]

    [Same structure as Component 1]

    ---

    ## üìä Implementation Summary

    ### Build Order
    1. **[Component 1 name]** - Foundation component
    2. **[Component 2 name]** - Secondary component

    ### Technical Requirements
    - ‚úÖ Self-contained HTML files
    - ‚úÖ Embedded CSS (no external stylesheets)
    - ‚úÖ Vanilla JavaScript (if needed)
    - ‚úÖ Responsive design
    - ‚úÖ Semantic HTML5
    - ‚úÖ Accessibility compliant

    ### Quality Standards
    - **Accuracy:** 90%+ match to design
    - **Performance:** Lightweight, optimized
    - **Compatibility:** Modern browsers (Chrome, Firefox, Safari, Edge)
    - **Maintainability:** Clean, commented code

    ---

    ## üéØ Success Metrics

    | Metric | Target |
    |--------|--------|
    | Design Accuracy | 90%+ |
    | Code Quality | Production-ready |
    | Load Time | < 1s |
    | Accessibility | WCAG 2.1 AA |

    ---

    *üìù This specification guides the component creation phase to ensure pixel-perfect implementation.*

    CRITICAL LIMITS:
    - Maximum 2 components ONLY - EXACTLY 2, NO MORE
    - Choose ONLY the 2 most important top-level components
    - Typically: navbar + one other major component (hero or footer)
    - Skip smaller elements like individual icons, text blocks, or utility components
    - Quality over quantity - fewer components done well is better

    List components from top to bottom as they appear in the design.
    Use clear, descriptive names that will become filenames (lowercase, hyphens).

  expected_output: >
    IMPORTANT: Output ONLY the component specification content as described in the template.
    Do NOT create additional explanatory text or meta-descriptions.

    A professional, production-ready Markdown document that will be saved as component_list.md with:
    - Clear hierarchical structure with headers starting with "# üß© Component Specification"
    - Tables for structured specifications
    - Code blocks for layout descriptions
    - Emojis for visual organization
    - Detailed specifications for each component including colors, typography, spacing, features
    - Implementation guidelines and quality standards
    - Easy for developers to reference during coding

    The document should be comprehensive enough that a developer can build the components
    without referring back to the design analysis.

    OUTPUT FORMAT: Start directly with "# üß© Component Specification" header.
    Do not include any meta-commentary about the file creation.
  agent: ui_architect
  context:
    - design_analysis_task

component_creation_task:
  description: >
    Create pixel-perfect HTML/CSS components for each component in the list EXACTLY ONCE.

    CRITICAL RULES:
    1. Read component_list.md to get the EXACT list of components to create
    2. There should be EXACTLY 2 components in the list
    3. Create each component EXACTLY ONCE - no duplicates
    4. After writing a file, NEVER create it again
    5. After BOTH components are created, you are DONE - provide summary and STOP
    6. Do NOT loop back to create more components

    STEP 1: READ component_list.md FILE
    - Open and read the output-ui_architect/component_list.md file
    - Extract the 2 component names from the markdown (look in "Selected Components" section)
    - Count the total number: Should be exactly 2 components
    - Write down the 2 component names and their specifications

    STEP 2: READ THE DESIGN ANALYSIS
    Before creating ANY component, review the design analysis report and extract:
    - EXACT color codes (e.g., Purple: #4B3C99, Orange: #E85C23)
    - EXACT font sizes, weights, and line heights
    - EXACT spacing values (padding, margins, gaps)
    - ACTUAL content text from the design (e.g., "IMPACTO JUVENTUD", "Sobre", "Nuestro Trabajo", "DONAR")
    - Layout structure and positioning

    STEP 2: CREATE COMPONENTS WITH 90%+ ACCURACY
    For EACH component, you MUST:

    1. USE EXACT COLORS - No guessing or approximation:
       - Look up the exact hex codes from the design analysis
       - Primary Purple: Use the EXACT value from analysis
       - Primary Orange: Use the EXACT value from analysis
       - All other colors: Use EXACT values from analysis

    2. USE EXACT CONTENT - Match what's actually in the design:
       - If the navbar shows "IMPACTO JUVENTUD", use that exact text
       - If buttons say "DONAR", use that exact text
       - If links say "Sobre", "Nuestro Trabajo", "Recursos", use those exact texts
       - Match the language (Spanish, English, etc.) from the design

    3. USE EXACT TYPOGRAPHY:
       - Font sizes from the analysis (e.g., 14px, 16px, 48px)
       - Font weights from the analysis (e.g., 400, 500, 700)
       - Line heights from the analysis
       - Text transforms (uppercase, etc.) as shown in design

    4. USE EXACT SPACING:
       - Padding values from the analysis
       - Margin values from the analysis
       - Gap values between elements
       - Component heights and widths

    5. MATCH VISUAL STRUCTURE:
       - Element positioning (left, center, right) - USE EXACT ALIGNMENT from analysis
       - Flexbox/Grid layouts as described
       - Background colors/images
       - Shadows, borders, border-radius

    6. IMPLEMENT INTERACTIVE ELEMENTS:
       - If component has DROPDOWNS: Add dropdown indicators (‚ñº) and positioning
       - If component is a CAROUSEL: Add carousel dots, arrows, and basic JS
       - If component has HOVER states: Add CSS :hover effects
       - Use vanilla JavaScript for interactions (no external libraries)

    SPECIAL: NAVBAR/HEADER 100% ACCURACY REQUIREMENTS
    The navbar is THE MOST CRITICAL component. For navbar.html, you MUST achieve 100% accuracy:

    1. EXACT LAYOUT STRUCTURE:
       - Measure the design: Is it 3-section layout (logo | nav | button)?
       - Logo container: justify-content: flex-start
       - Nav links container: justify-content: center OR flex-start (check design!)
       - CTA/Right section: justify-content: flex-end
       - Use display: flex with space-between for main container

    2. EXACT SPACING (CRITICAL):
       - Logo-to-nav gap: Measure and match exactly (e.g., 40px, 60px)
       - Gap between nav items: Match exactly (e.g., 32px, 40px)
       - Navbar height: Match exactly (e.g., 70px, 80px, 90px)
       - Horizontal padding: Match exactly (e.g., 24px, 40px, 60px)

    3. EXACT ALIGNMENT:
       - Logo: LEFT side, vertically centered
       - Nav links: CENTER or LEFT (check design!), vertically centered
       - If nav is CENTER: Use separate flex container with justify-content: center
       - If nav is LEFT with logo: Put both in same flex-start container
       - Buttons/Icons: RIGHT side, vertically centered

    4. EXACT CONTENT:
       - Logo text/image: EXACT text from design
       - Each nav link: EXACT text from design (case-sensitive)
       - Dropdown indicators: Add ‚ñº only to items that have it in design
       - Button text: EXACT text from design

    5. PERFECT VERTICAL CENTERING:
       - All elements: align-items: center
       - Logo, nav items, buttons: all perfectly aligned vertically

    STEP 3: TECHNICAL REQUIREMENTS
    - Each component must be self-contained (no external CSS files)
    - Include <!DOCTYPE html>, <html>, <head>, and <body>
    - Embed all CSS in <style> tags in the <head>
    - Use CSS variables for colors for consistency
    - Use semantic HTML5 elements
    - Make components responsive
    - Add clear comments
    - Include <script> tags for interactive components (carousels, dropdowns, etc.)
    - Ensure exact alignment matches the design (justify-content: flex-start/center/flex-end)

    STEP 4: USE THE FILE WRITER TOOL
    For each component, use the "File Writer" tool with:
    - filename: Component name with .html extension (e.g., "navbar.html")
    - content: Complete HTML document
    - folder: "output-ui_architect" (default, can be omitted)

    STEP 5: CREATE EXACTLY 2 COMPONENTS - TRACK YOUR PROGRESS

    Component 1 (from list):
    - Use File Writer tool to create output-ui_architect/[component-1-name].html
    - Mark: ‚úì DONE with component 1

    Component 2 (from list):
    - Use File Writer tool to create output-ui_architect/[component-2-name].html
    - Mark: ‚úì DONE with component 2

    STEP 6: FINAL CHECK - BOTH 2 COMPONENTS CREATED? YES ‚Üí STOP NOW!
    After creating the 2nd component, you have completed ALL components.

    Final checklist:
    ‚úì Component 1 created?
    ‚úì Component 2 created?

    If BOTH are YES: YOU ARE DONE. Provide final summary and STOP IMMEDIATELY.

    DO NOT:
    - Create any component twice
    - Create more than 2 components
    - Create additional components not in the list
    - Loop back to create more files
    - Continue after both components are created

  expected_output: >
    FINAL SUMMARY - 2 components created:

    ‚úì output-ui_architect/[component-1].html - Created successfully
    ‚úì output-ui_architect/[component-2].html - Created successfully

    TOTAL: 2 files created in output-ui_architect/ folder
    STATUS: COMPLETE - All components from the list have been created
    NEXT STEP: Task is finished, no further action needed
  agent: ui_architect
  context:
    - design_analysis_task
    - component_listing_task

aem_component_list_task:
  description: >
    List all available HTML components from the output-ui_architect/ folder and present them
    to the user for selection.

    STEP 1: Scan the output-ui_architect directory for .html files
    STEP 2: Create a list of all HTML components found
    STEP 3: For each component, extract:
       - Component filename (e.g., navbar.html)
       - Component name (e.g., navbar)
       - Brief description if available from the file

    STEP 4: Present the list to the user in a clear format:

    Available HTML Components:
    1. navbar.html - Navigation component
    2. hero-section.html - Hero section component
    3. button-primary.html - Primary button component
    ... etc

    STEP 5: Ask user which component to convert to AEM
    Use the AskUserQuestion tool to let the user select ONE component

  expected_output: >
    A clear list of available HTML components and the user's selection
    for which component to convert to AEM next.
  agent: aem_alchemist

aem_component_conversion_task:
  description: >
    Transform JSON component specification into production-ready AEM component with 100% accuracy.

    INPUT: JSON specification from output-visual_strategist/design_analysis.json

    STEP 1: READ & PARSE JSON SPECIFICATION
    Use FileReaderTool to read: output-visual_strategist/design_analysis.json

    Parse the JSON structure:
    - component: {name, type, width, height}
    - colors: {background, text, primary, secondary, ...}
    - layout: {display, justify, align, padding, gap}
    - elements: [{type, text, position, fontSize, color, ...}]

    Extract component name (e.g., "hero-banner" from component.name)

    STEP 2: CREATE COMPONENT DEFINITION (.content.xml)
    Location: ui.apps/src/main/content/jcr_root/apps/your-app/components/component-name/.content.xml

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <jcr:root xmlns:cq="http://www.day.com/jcr/cq/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0"
        jcr:primaryType="cq:Component"
        jcr:title="[Component Display Name from JSON]"
        jcr:description="[Component Description]"
        componentGroup="Content Components"/>
    ```

    STEP 3: CREATE HTL TEMPLATE (Production-Grade)
    Location: ui.apps/src/main/content/jcr_root/apps/your-app/components/component-name/component-name.html

    CRITICAL HTL RULES:
    1. Start with data-sly-use to load Sling Model:
       <sly data-sly-use.model="com.example.core.models.ComponentNameModel"/>

    2. Create semantic HTML structure matching JSON layout:
       - Use proper HTML5 tags (header, section, article, nav, button, etc.)
       - Apply BEM naming convention for CSS classes
       - Add data-sly-test for optional elements

    3. Map JSON elements to HTL:
       For each element in JSON elements array:
       - type="heading" ‚Üí <h1/h2/h3 data-sly-test="${model.heading}">${model.heading}</h1>
       - type="paragraph" ‚Üí <p data-sly-test="${model.description}">${model.description}</p>
       - type="button" ‚Üí <a class="btn" href="${model.buttonLink}" data-sly-test="${model.buttonText}">${model.buttonText}</a>
       - type="image" ‚Üí <img src="${model.imagePath}" alt="${model.imageAlt}" data-sly-test="${model.imagePath}"/>
       - type="carouselIndicators" ‚Üí <div data-sly-list="${model.slides}">...</div>

    4. Add CSS classes from JSON:
       - Use component name as base class: class="hero-banner"
       - Add element classes: class="hero-banner__heading"
       - Reference ClientLib: <sly data-sly-use.clientlib="/libs/granite/sightly/templates/clientlib.html"/>

    5. Example HTL for hero-banner:
       ```html
       <sly data-sly-use.model="com.example.core.models.HeroBannerModel"/>
       <section class="hero-banner" style="background-color: ${model.backgroundColor}">
         <div class="hero-banner__content">
           <h1 class="hero-banner__heading" data-sly-test="${model.heading}">${model.heading}</h1>
           <p class="hero-banner__text" data-sly-test="${model.description}">${model.description}</p>
           <a href="${model.ctaLink}" class="hero-banner__button" data-sly-test="${model.ctaText}">${model.ctaText}</a>
         </div>
         <img src="${model.imagePath}" alt="${model.imageAlt}" class="hero-banner__image" data-sly-test="${model.imagePath}"/>
       </section>
       ```

    STEP 4: CREATE SLING MODEL (Enterprise Java)
    Location: core/src/main/java/com/example/core/models/ComponentNameModel.java

    CRITICAL SLING MODEL RULES:
    1. Package naming: com.example.core.models
    2. Class naming: ComponentNameModel (PascalCase - convert component.name from JSON)
    3. Proper annotations and JavaDoc

    Template:
    ```java
    package com.example.core.models;

    import org.apache.sling.api.resource.Resource;
    import org.apache.sling.models.annotations.Model;
    import org.apache.sling.models.annotations.injectorspecific.ValueMapValue;
    import org.apache.sling.models.annotations.DefaultInjectionStrategy;

    /**
     * Sling Model for Component component.
     * Provides authoring fields for all editable properties.
     */
    @Model(adaptables = Resource.class, defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL)
    public class ComponentNameModel {

        // Map each editable field from JSON to @ValueMapValue
        // For text elements:
        @ValueMapValue
        private String heading;

        @ValueMapValue
        private String description;

        @ValueMapValue
        private String buttonText;

        @ValueMapValue
        private String buttonLink;

        // For images:
        @ValueMapValue
        private String imagePath;

        @ValueMapValue
        private String imageAlt;

        // For colors from JSON:
        @ValueMapValue
        private String backgroundColor;

        // Getters with JavaDoc
        /**
         * Gets the main heading text.
         * @return the heading text
         */
        public String getHeading() {
            return heading;
        }

        public String getDescription() {
            return description;
        }

        public String getButtonText() {
            return buttonText;
        }

        public String getButtonLink() {
            return buttonLink;
        }

        public String getImagePath() {
            return imagePath;
        }

        public String getImageAlt() {
            return imageAlt;
        }

        public String getBackgroundColor() {
            return backgroundColor;
        }
    }
    ```

    STEP 5: CREATE DIALOG XML (Author-Friendly)
    Location: ui.apps/src/main/content/jcr_root/apps/your-app/components/component-name/_cq_dialog.xml

    CRITICAL DIALOG RULES:
    1. Use Touch UI coral3 components
    2. Organize fields in logical tabs: Content, Styling
    3. Add helpful fieldDescription for authors
    4. Use proper field types based on JSON element types

    Template:
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0" xmlns:granite="http://www.adobe.com/jcr/granite/1.0"
        xmlns:cq="http://www.day.com/jcr/cq/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
        jcr:primaryType="nt:unstructured"
        jcr:title="Component Display Name"
        sling:resourceType="cq/gui/components/authoring/dialog">
        <content jcr:primaryType="nt:unstructured" sling:resourceType="granite/ui/components/coral/foundation/container">
            <items jcr:primaryType="nt:unstructured">
                <tabs jcr:primaryType="nt:unstructured" sling:resourceType="granite/ui/components/coral/foundation/tabs" maximized="true">
                    <items jcr:primaryType="nt:unstructured">

                        <!-- Content Tab -->
                        <content jcr:primaryType="nt:unstructured" jcr:title="Content" sling:resourceType="granite/ui/components/coral/foundation/container">
                            <items jcr:primaryType="nt:unstructured">

                                <!-- For each text element in JSON -->
                                <heading jcr:primaryType="nt:unstructured"
                                    sling:resourceType="granite/ui/components/coral/foundation/form/textfield"
                                    fieldLabel="Heading"
                                    fieldDescription="Main heading text"
                                    name="./heading"/>

                                <description jcr:primaryType="nt:unstructured"
                                    sling:resourceType="granite/ui/components/coral/foundation/form/textarea"
                                    fieldLabel="Description"
                                    fieldDescription="Description text"
                                    name="./description"/>

                                <buttonText jcr:primaryType="nt:unstructured"
                                    sling:resourceType="granite/ui/components/coral/foundation/form/textfield"
                                    fieldLabel="Button Text"
                                    name="./buttonText"/>

                                <buttonLink jcr:primaryType="nt:unstructured"
                                    sling:resourceType="granite/ui/components/coral/foundation/form/pathfield"
                                    fieldLabel="Button Link"
                                    name="./buttonLink"
                                    rootPath="/content"/>

                                <imagePath jcr:primaryType="nt:unstructured"
                                    sling:resourceType="cq/gui/components/authoring/dialog/fileupload"
                                    fieldLabel="Image"
                                    name="./imagePath"
                                    mimeTypes="[image/png,image/jpeg]"/>

                            </items>
                        </content>

                        <!-- Styling Tab -->
                        <styling jcr:primaryType="nt:unstructured" jcr:title="Styling" sling:resourceType="granite/ui/components/coral/foundation/container">
                            <items jcr:primaryType="nt:unstructured">

                                <!-- For colors from JSON -->
                                <backgroundColor jcr:primaryType="nt:unstructured"
                                    sling:resourceType="granite/ui/components/coral/foundation/form/colorfield"
                                    fieldLabel="Background Color"
                                    name="./backgroundColor"/>

                            </items>
                        </styling>

                    </items>
                </tabs>
            </items>
        </content>
    </jcr:root>
    ```

    STEP 6: CREATE CLIENTLIB (CSS from JSON)
    Location: ui.apps/src/main/content/jcr_root/apps/your-app/clientlibs/clientlib-component-name/

    A. .content.xml:
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <jcr:root xmlns:cq="http://www.day.com/jcr/cq/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0"
        jcr:primaryType="cq:ClientLibraryFolder"
        categories="[component.component-name]"/>
    ```

    B. css.txt:
    ```
    component-name.css
    ```

    C. component-name.css (Generate from JSON):
    Convert JSON colors, layout, spacing to CSS:
    ```css
    .hero-banner {
      /* From JSON layout */
      display: flex;
      align-items: center;
      padding: 80px 60px;
      gap: 32px;

      /* From JSON colors */
      background-color: #D4C4B0;
      color: #3C3C3C;

      /* From JSON dimensions */
      width: 100%;
      height: 594px;
    }

    .hero-banner__heading {
      /* From JSON elements[type="heading"] */
      font-size: 50px;
      font-weight: 700;
      color: #3C3C3C;
      line-height: 1.2;
      margin-bottom: 24px;
    }

    /* Continue for all elements... */
    ```

    STEP 7: USE FILE WRITER TOOL
    Use FileWriterTool to write each file to LOCAL output folder:

    1. Component Definition: output-aem-component/component-name/.content.xml
    2. HTL Template: output-aem-component/component-name/component-name.html
    3. Sling Model: output-aem-component/component-name/ComponentNameModel.java
    4. Dialog: output-aem-component/component-name/_cq_dialog.xml
    5. ClientLib .content.xml: output-aem-component/component-name/clientlib/.content.xml
    6. ClientLib css.txt: output-aem-component/component-name/clientlib/css.txt
    7. ClientLib CSS: output-aem-component/component-name/clientlib/component-name.css

    STEP 8: QUALITY CHECKLIST
    Before finishing, verify:
    ‚úÖ All 7 files created successfully
    ‚úÖ HTL uses data-sly-use with correct model path
    ‚úÖ HTL has data-sly-test for optional elements
    ‚úÖ Sling Model has @ValueMapValue for all properties
    ‚úÖ Sling Model has getters with JavaDoc
    ‚úÖ Dialog has all fields with proper labels
    ‚úÖ CSS generated from JSON colors, layout, spacing
    ‚úÖ BEM naming convention used in HTL and CSS
    ‚úÖ Production-ready code quality

  expected_output: >
    PRODUCTION-READY AEM COMPONENT CREATED:

    ‚úÖ Component Definition (.content.xml)
       - Location: output-aem-component/component-name/.content.xml
       - Status: Created with proper metadata

    ‚úÖ HTL Template (component-name.html)
       - Location: output-aem-component/component-name/component-name.html
       - Status: Created with data-sly attributes, semantic HTML, BEM classes

    ‚úÖ Sling Model (ComponentNameModel.java)
       - Location: output-aem-component/component-name/ComponentNameModel.java
       - Status: Created with @Model annotation, @ValueMapValue properties, JavaDoc

    ‚úÖ Dialog (_cq_dialog.xml)
       - Location: output-aem-component/component-name/_cq_dialog.xml
       - Status: Created with Touch UI fields, tabs, proper labels

    ‚úÖ ClientLib (CSS/JS)
       - Location: output-aem-component/component-name/clientlib/
       - Status: Created with .content.xml, css.txt, component-name.css

    NEXT STEP: Review generated files in output-aem-component/ folder
  agent: aem_alchemist
  context:
    - design_analysis_task

# ============================================
# MULTI-TASK BREAKDOWN: Separate AEM File Generation
# ============================================

aem_component_definition_task:
  description: >
    STEP 1 of 6: Create AEM Component Definition (.content.xml)

    Read JSON: output-visual_strategist/design_analysis.json
    Extract: component.name (e.g., "hero-banner"), component.type (e.g., "hero-section")

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}
    - AEM App ID: {aem_app_id}
    - Component Group: {aem_component_group}

    Calculate the correct path:
    Path = {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/.content.xml

    Example: If aem_project_path="/Users/dev/my-aem-project", aem_app_id="myapp", component.name="hero-banner":
    Full path: /Users/dev/my-aem-project/ui.apps/src/main/content/jcr_root/apps/myapp/components/hero-banner/.content.xml

    Template:
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <jcr:root xmlns:cq="http://www.day.com/jcr/cq/1.0" xmlns:jcr="http://www.jcp.org/jcr/1.0"
        jcr:primaryType="cq:Component"
        jcr:title="[Readable Component Name]"
        jcr:description="[Component Type] component generated from design specs"
        componentGroup="{aem_component_group}"/>
    ```

    Use AEM File Writer tool to write the file to the AEM project path.
    Provide: file_path (relative from AEM root), content (XML), aem_project_path (absolute path).
    The tool will automatically create any missing parent directories.

  expected_output: >
    ‚úÖ 1/6 COMPLETE: Component definition created at:
    {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/.content.xml
  agent: aem_alchemist
  context:
    - design_analysis_task

aem_htl_generation_task:
  description: >
    STEP 2 of 6: Create HTL Template (Production-Grade)

    Read JSON: output-visual_strategist/design_analysis.json

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}
    - AEM App ID: {aem_app_id}
    - AEM Namespace: {aem_namespace}

    Calculate the correct path:
    Path = {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/[component-name].html

    Example: If aem_project_path="/Users/dev/my-aem-project", aem_app_id="myapp", component.name="hero-banner":
    Full path: /Users/dev/my-aem-project/ui.apps/src/main/content/jcr_root/apps/myapp/components/hero-banner/hero-banner.html

    BEFORE GENERATING - CRITICAL ANALYSIS:

    1. **Identify Repeating Elements** (Must be dynamic, NOT hardcoded):
       - Look for: socialIcons, navLinks, cards, slides, menuItems, footerLinks
       - These MUST use data-sly-list="${model.property}" for iteration
       - DO NOT hardcode multiple <li> items - use ONE <li> with data-sly-list!

    2. **Plan BEM Class Naming Strategy**:
       - Decide: Use "cmp-" prefix (Adobe standard) or not?
       - Whatever you choose, use it CONSISTENTLY throughout HTL
       - Write down your class naming: .cmp-footer, .cmp-footer__logo, etc.
       - This EXACT naming will be used in SCSS file later!

    Generate HTL with:
    1. data-sly-use.model="com.{aem_namespace}.core.models.[ComponentName]Model" (convert component.name to PascalCase)
    2. Semantic HTML5 structure (section, div, h1, p, button, img, etc.)
    3. BEM CSS classes based on component.name with CONSISTENT prefix (e.g., .cmp-footer__heading)
    4. data-sly-test for optional elements
    5. Map JSON elements array to HTL:
       - type="heading" ‚Üí <h1 data-sly-test="${model.heading}">${model.heading}</h1>
       - type="paragraph" ‚Üí <p data-sly-test="${model.description}">${model.description}</p>
       - type="button" ‚Üí <a href="${model.buttonLink}">${model.buttonText}</a>
       - type="image" ‚Üí <img src="${model.imagePath}" alt="[alt]"/>
       - type="socialIcons" ‚Üí <li data-sly-list.icon="${model.socialIcons}">...</li> (NOT hardcoded list!)
       - type="navLinks" ‚Üí <li data-sly-list.link="${model.navLinks}">...</li> (NOT hardcoded list!)
       - type="carouselIndicators" ‚Üí <div data-sly-list="${model.slides}">...</div>

    VERIFICATION BEFORE WRITING FILE - Stop and check:
    ‚úì No hardcoded lists? (All <li> items use data-sly-list?)
    ‚úì All classes use same naming pattern? (all "cmp-X" or all "X"?)
    ‚úì All dynamic content from ${model.property}? (no hardcoded text/links?)
    ‚úì All optional elements have data-sly-test?

    Use AEM File Writer tool to write file to the AEM project path.
    Provide: file_path (relative from AEM root), content, aem_project_path (absolute path).

  expected_output: >
    ‚úÖ 2/6 COMPLETE: HTL template created at:
    {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/[component-name].html
    - Semantic HTML5
    - data-sly attributes
    - BEM naming
  agent: aem_alchemist
  context:
    - design_analysis_task
    - aem_component_definition_task

aem_sling_model_generation_task:
  description: >
    STEP 3 of 6: Create Sling Model (Enterprise Java)

    Read JSON: output-visual_strategist/design_analysis.json

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}
    - AEM Namespace: {aem_namespace}

    Calculate the correct path:
    Path = {aem_project_path}/core/src/main/java/com/{aem_namespace}/core/models/[ComponentName]Model.java

    Example: If aem_project_path="/Users/dev/my-aem-project", aem_namespace="mycompany/myapp", component.name="hero-banner":
    Full path: /Users/dev/my-aem-project/core/src/main/java/com/mycompany/myapp/core/models/HeroBannerModel.java

    Generate Sling Model with INTELLIGENT PROPERTY EXTRACTION:

    1. **Package**: com.{aem_namespace}.core.models (convert slashes to dots: "mohhwebsites" ‚Üí "mohhwebsites")

    2. **Class Name**: Convert component.name to PascalCase + "Model"
       - "footer" ‚Üí "FooterModel"
       - "hero-banner" ‚Üí "HeroBannerModel"
       - "rotating-teaser-cards" ‚Üí "RotatingTeaserCardsModel"

    3. **Analyze JSON Elements Array** - For EACH element in JSON:
       - If element has "text" property ‚Üí Create String field (e.g., logoText, headingText, descriptionText)
       - If element has "href"/"link" ‚Üí Create String field (e.g., ctaLink, buttonLink)
       - If element has "image"/"src" ‚Üí Create String field (e.g., imagePath, logoSrc)
       - If element has "items" array ‚Üí Create @ChildResource List<Resource> field + inner class
       - If element has colors ‚Üí Create color fields from JSON colors object
       - If element type="button" ‚Üí buttonText, buttonLink, buttonStyle properties
       - If element type="icon"/"socialIcons" ‚Üí CRITICAL:
         * Create @ChildResource List<Resource> socialIcons field
         * Create inner class SocialIcon with: platform, url, size, color
         * Add getIconSvg() method that returns SVG string based on platform
         * Supports: facebook, twitter, instagram, youtube, linkedin, tiktok
       - If element type="navLinks" ‚Üí Create navigation-related fields with List + inner class NavItem
       - If element type="form" ‚Üí Create form-related fields
       - If element type="carousel" ‚Üí Create slides/autoRotate fields

    4. **Follow Rotating Teaser Cards Pattern**:
       ```java
       @Model(adaptables = {{SlingHttpServletRequest.class, Resource.class}},
              adapters = [ComponentName]Model.class,
              defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL)
       public class [ComponentName]Model {

         // Extract from JSON colors object
         @ValueMapValue
         @Default(values = "#FFFFFF")
         private String backgroundColor;

         // Extract from JSON elements
         @ValueMapValue
         private String [propertyName];

         // For repeated items (cards, slides, nav items)
         @ChildResource
         private List<Resource> [itemsName];

         private List<[ItemClass]> validated[Items];

         @PostConstruct
         protected void init() {
           // Validation logic if needed
         }

         // Getters with JavaDoc for ALL properties
         /**
          * Gets the [property description]
          * @return [property description]
          */
         public String get[PropertyName]() {
           return [propertyName];
         }

         // Inner class for child items if needed
         public class [ItemClass] {
           private Resource resource;
           // Properties from JSON items array
         }
       }
       ```

    5. **Smart Property Naming**:
       - Use descriptive names based on element type and context
       - For multiple text elements: sectionHeading, cardTitle, footerDescription
       - For multiple links: primaryLink, secondaryLink, ctaLink
       - For images: heroImage, thumbnailImage, backgroundImage

    6. **Add Validation Methods** (like RotatingTeaserCards):
       - isValid() method checking required fields
       - getCardsCount() or getItemsCount() for collections
       - Proper @PostConstruct initialization

    Use AEM File Writer tool to write file to the AEM project path.
    Provide: file_path (relative from AEM root), content, aem_project_path (absolute path).

  expected_output: >
    ‚úÖ 3/6 COMPLETE: Sling Model created at:
    {aem_project_path}/core/src/main/java/com/{aem_namespace}/core/models/[ComponentName]Model.java
    - @Model annotation
    - @ValueMapValue properties
    - Getters with JavaDoc
  agent: aem_alchemist
  context:
    - design_analysis_task
    - aem_htl_generation_task

aem_dialog_generation_task:
  description: >
    STEP 4 of 6: Create Touch UI Dialog (Author-Friendly)

    Read JSON: output-visual_strategist/design_analysis.json

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}
    - AEM App ID: {aem_app_id}

    Calculate the correct path:
    Path = {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/_cq_dialog.xml

    Example: If aem_project_path="/Users/dev/my-aem-project", aem_app_id="myapp", component.name="hero-banner":
    Full path: /Users/dev/my-aem-project/ui.apps/src/main/content/jcr_root/apps/myapp/components/hero-banner/_cq_dialog.xml

    Generate Dialog with INTELLIGENT FIELD MAPPING:

    1. **Analyze Sling Model Properties** - Read the generated Sling Model and create dialog fields for EACH property

    2. **Smart Field Type Selection** based on property name/type:
       - **textfield**: heading, title, label, text, name, copyright, tagline (< 100 chars)
       - **textarea**: description, paragraph, content, body (> 100 chars)
       - **pathfield**: link, href, url, path, ctaLink, buttonLink
       - **fileupload**: image, imagePath, logoSrc, thumbnailImage, backgroundImage
       - **colorfield**: color, backgroundColor, textColor, borderColor, accentColor
       - **checkbox**: enable, show, display, autoRotate, enableAutoPlay
       - **numberfield**: delay, duration, count, maxItems, autoRotateDelay
       - **multifield**: For @ChildResource List fields (navLinks, cards, slides, socialIcons)

    3. **Dynamic Tab Organization**:
       - **Content Tab**: All text fields, links, images
       - **Styling Tab**: All color fields, background, borders
       - **Behavior Tab** (if needed): checkboxes, number fields for behavior control
       - **Items Tab** (if multifield exists): Repeatable items (cards/slides/navLinks)

    4. **Follow Rotating Teaser Cards Dialog Pattern**:
       ```xml
       <?xml version="1.0" encoding="UTF-8"?>
       <jcr:root xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
           xmlns:granite="http://www.adobe.com/jcr/granite/1.0"
           xmlns:cq="http://www.day.com/jcr/cq/1.0"
           xmlns:jcr="http://www.jcp.org/jcr/1.0"
           xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
           jcr:primaryType="nt:unstructured"
           jcr:title="[Component Display Name]"
           sling:resourceType="cq/gui/components/authoring/dialog">
         <content jcr:primaryType="nt:unstructured" sling:resourceType="granite/ui/components/coral/foundation/container">
           <items jcr:primaryType="nt:unstructured">
             <tabs jcr:primaryType="nt:unstructured" sling:resourceType="granite/ui/components/coral/foundation/tabs">
               <items jcr:primaryType="nt:unstructured">

                 <!-- Content Tab -->
                 <content jcr:primaryType="nt:unstructured" jcr:title="Content">
                   <items jcr:primaryType="nt:unstructured">
                     <!-- Add fields for all text/image/link properties -->
                   </items>
                 </content>

                 <!-- Styling Tab (if color fields exist) -->
                 <styling jcr:primaryType="nt:unstructured" jcr:title="Styling">
                   <items jcr:primaryType="nt:unstructured">
                     <!-- Add color fields -->
                   </items>
                 </styling>

                 <!-- Items Tab (if @ChildResource exists) -->
                 <items jcr:primaryType="nt:unstructured" jcr:title="[Items Name]">
                   <items jcr:primaryType="nt:unstructured">
                     <multifield sling:resourceType="granite/ui/components/coral/foundation/form/multifield">
                       <field jcr:primaryType="nt:unstructured" sling:resourceType="granite/ui/components/coral/foundation/container">
                         <!-- Inner fields for each item -->
                       </field>
                     </multifield>
                   </items>
                 </items>

               </items>
             </tabs>
           </items>
         </content>
       </jcr:root>
       ```

    5. **Field Best Practices**:
       - Always add fieldLabel and fieldDescription
       - Use required="true" for critical fields (Boolean type in AEM)
       - Add validation for max lengths matching Sling Model
       - Use granite/ui/components/coral/foundation/form/* components
       - Match name="./propertyName" exactly with Sling Model

    6. **Handle Special Cases**:
       - Social icons: Create multifield with platform dropdown (facebook, twitter, instagram, youtube, linkedin, tiktok) + URL field + size/color fields
       - Navigation links: Create multifield with text + href + newWindow checkbox
       - Carousels: Add auto-rotate settings + slides multifield
       - Forms: Add field type selectors + validation options

    7. **CRITICAL: Complete XML Structure Validation**:
       MUST include ALL required XML elements for valid Touch UI dialog:

       ‚úì XML declaration: <?xml version="1.0" encoding="UTF-8"?>
       ‚úì Root <jcr:root> with ALL namespaces:
         - xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
         - xmlns:granite="http://www.adobe.com/jcr/granite/1.0"
         - xmlns:cq="http://www.day.com/jcr/cq/1.0"
         - xmlns:jcr="http://www.jcp.org/jcr/1.0"
         - xmlns:nt="http://www.jcp.org/jcr/nt/1.0"
       ‚úì jcr:primaryType="nt:unstructured" on root
       ‚úì jcr:title attribute on root
       ‚úì sling:resourceType="cq/gui/components/authoring/dialog" on root
       ‚úì <content> element with jcr:primaryType and sling:resourceType
       ‚úì Nested <items> elements with jcr:primaryType="nt:unstructured"
       ‚úì <tabs> element with sling:resourceType
       ‚úì Every tab has: jcr:primaryType, jcr:title, sling:resourceType
       ‚úì Every field has: jcr:primaryType, sling:resourceType, fieldLabel, name
       ‚úì Proper closing tags: </content>, </items>, </tabs>, </jcr:root>

       NEVER generate incomplete/truncated XML! If XML is too long, organize better, don't cut it off.

    VERIFICATION BEFORE WRITING FILE - Dialog XML Structure Check:
    ‚úì XML declaration present?
    ‚úì All 5 XML namespaces defined on root element?
    ‚úì Root element properly closed with </jcr:root>?
    ‚úì All tabs have proper structure (jcr:primaryType, jcr:title, sling:resourceType)?
    ‚úì Every field has name="./propertyName" matching Sling Model?
    ‚úì Multifields properly structured with <field> container?
    ‚úì No incomplete/truncated XML? (Must be complete and well-formed)

    Use AEM File Writer tool to write to: {aem_project_path}/ui.apps/.../components/[component-name]/_cq_dialog/.content.xml
    Provide: file_path (relative from AEM root), content (XML), aem_project_path (absolute path).
    (Note: The path should include _cq_dialog/.content.xml - the tool will create the folder automatically)

  expected_output: >
    ‚úÖ 4/6 COMPLETE: Dialog created at:
    {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/_cq_dialog.xml
    - Touch UI tabs
    - Author-friendly fields
    - Proper labels
  agent: aem_alchemist
  context:
    - design_analysis_task
    - aem_sling_model_generation_task

aem_frontend_scss_generation_task:
  description: >
    STEP 5 of 6: Create SCSS File (Frontend Styles)

    Read JSON: output-visual_strategist/design_analysis.json
    Extract component.name for file paths and CSS classes.

    CRITICAL FIRST STEP - READ THE HTL FILE:
    Before generating SCSS, READ the HTL template file you created earlier to get the EXACT CSS classes used.
    Path to read: {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/[component-name].html

    Extract all CSS classes from HTL:
    - Look for: class="cmp-footer", class="cmp-footer__logo", class="cmp-footer__social-icon", etc.
    - List ALL classes found in HTL
    - Your SCSS MUST match these EXACT class names!

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}

    Calculate the correct path:
    Path = {aem_project_path}/ui.frontend/src/main/webpack/components/_[component-name].scss

    Example: If aem_project_path="/Users/dev/my-aem-project", component.name="footer":
    Full path: /Users/dev/my-aem-project/ui.frontend/src/main/webpack/components/_footer.scss

    Generate SCSS file with INTELLIGENT STYLE GENERATION:

    1. **Analyze Component Type** from JSON:
       - Footer ‚Üí sticky footer, multi-column layout, social icons
       - Header/Navbar ‚Üí fixed positioning, z-index, responsive menu
       - Hero ‚Üí full-height, background images, overlay
       - Card ‚Üí box-shadow, border-radius, hover effects
       - Carousel ‚Üí transitions, overflow hidden, indicator dots
       - Form ‚Üí input styling, validation states, focus rings
       - Modal ‚Üí overlay, centered, transitions

    2. **BEM Naming Convention - MUST MATCH HTL EXACTLY**:
       - If HTL uses `.cmp-footer` ‚Üí SCSS uses `.cmp-footer`
       - If HTL uses `.footer` ‚Üí SCSS uses `.footer`
       - CRITICAL: Check what prefix HTL used and match it exactly!
       - Elements: Match HTL format (e.g., `.cmp-footer__logo` or `.footer__logo`)
       - Modifiers: Match HTL format (e.g., `.cmp-footer--dark`)

    3. **Generate Styles for Each JSON Element**:
       - For each element in JSON elements array ‚Üí Create BEM element class
       - Extract: fontSize, fontWeight, color, padding, margin, borderRadius
       - Add layout properties: display, flexbox/grid, positioning
       - Include spacing from JSON layout object

    4. **Responsive Design Patterns**:
       - Mobile-first approach with min-width media queries
       - @media (min-width: 768px) for tablet
       - @media (min-width: 1024px) for desktop
       - Adjust font sizes, spacing, layout direction

    5. **Interactive Element Styles**:
       - Buttons: hover, active, focus states with transitions
       - Links: hover color change, underline effects
       - Social icons: hover scale/color animations
       - Carousel: transition timing, indicator animations
       - Forms: focus rings, validation states

    6. **Component-Specific Patterns**:
       - **Navigation**: sticky/fixed positioning, mobile menu, dropdowns
       - **Footer**: multi-column grid, copyright alignment, dividers
       - **Carousel**: slide transitions, dot indicators, arrow buttons
       - **Cards**: hover elevation, image aspect ratios
       - **Forms**: input groups, error states, success states

    Example SCSS structure:
    ```scss
    .cmp-footer {
      background-color: #F5F5F5;
      padding: 30px 40px;

      &__logo {
        font-size: 48px;
        font-weight: 700;
        color: #7CB4E8;
      }

      &__nav {
        display: flex;
        gap: 25px;

        &-link {
          color: #666666;
          font-size: 16px;
        }
      }
    }
    ```

    VERIFICATION BEFORE WRITING FILE - Stop and check:
    ‚úì Read HTL file and extracted all CSS classes?
    ‚úì Every HTL class has corresponding SCSS rule? (no missing styles)
    ‚úì No extra SCSS classes that don't exist in HTL? (no orphaned styles)
    ‚úì Class naming exactly matches HTL? (.cmp-X matches .cmp-X, not .X)
    ‚úì Added list-style: none and padding: 0 for list elements?
    ‚úì Added display: flex/inline-flex for social icon containers?

    Use AEM File Writer tool to write the SCSS file to the AEM project path.
    Provide: file_path (relative from AEM root), content (SCSS), aem_project_path (absolute path).

  expected_output: >
    ‚úÖ 5/6 COMPLETE: SCSS file created at:
    {aem_project_path}/ui.frontend/src/main/webpack/components/_[component-name].scss
    - BEM naming convention matches HTL exactly
    - All HTL classes have corresponding styles
    - Responsive styles included
    - Component-specific variables defined
  agent: aem_alchemist
  context:
    - design_analysis_task
    - aem_dialog_generation_task

aem_frontend_js_generation_task:
  description: >
    STEP 6 of 6: Create JavaScript File (Frontend Behavior)

    Read JSON: output-visual_strategist/design_analysis.json
    Extract component.name and identify interactive elements.

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}

    Calculate the correct path:
    Path = {aem_project_path}/ui.frontend/src/main/webpack/components/_[component-name].js

    Example: If aem_project_path="/Users/dev/my-aem-project", component.name="footer":
    Full path: /Users/dev/my-aem-project/ui.frontend/src/main/webpack/components/_footer.js

    Generate JavaScript file with INTELLIGENT BEHAVIOR DETECTION:

    1. **Analyze Component Interactions** from JSON elements:
       - Carousel/Slider ‚Üí Auto-rotate, navigation arrows, dot indicators, swipe support
       - Dropdown/Accordion ‚Üí Toggle expand/collapse, keyboard navigation
       - Modal/Dialog ‚Üí Open/close, overlay click, escape key
       - Form ‚Üí Validation, submit handling, error display
       - Tabs ‚Üí Switch tabs, keyboard arrow navigation
       - Navigation ‚Üí Mobile menu toggle, dropdown menus
       - Social Icons ‚Üí Click tracking for analytics
       - Lazy Loading ‚Üí Intersection Observer for images
       - Infinite Scroll ‚Üí Load more on scroll
       - Search ‚Üí Autocomplete, filtering

    2. **IIFE Pattern** with strict mode:
       ```javascript
       (function() {
         'use strict';
         // Component code
       })();
       ```

    2.1 **CRITICAL: ES5 Compatibility** (AEM requires ES5, NOT ES6):
       - ‚ùå NO template literals: `const msg = \`Hello ${name}\`;` ‚Üê WRONG!
       - ‚úÖ Use string concatenation: `var msg = 'Hello ' + name;` ‚Üê CORRECT!
       - ‚ùå NO const/let: Use `var` only
       - ‚ùå NO arrow functions: `() =>` ‚Üê Use `function() {}` instead
       - ‚ùå NO destructuring, spread operators, classes
       - ‚úÖ Use ES5 syntax throughout (var, function, string concatenation)

       Example ES5-compatible code:
       ```javascript
       (function() {
         'use strict';

         var COMPONENT_SELECTOR = '.cmp-footer';

         function init() {
           var components = document.querySelectorAll(COMPONENT_SELECTOR);
           for (var i = 0; i < components.length; i++) {
             initializeComponent(components[i]);
           }
         }

         function logMessage(platform) {
           // ES5: String concatenation, NOT template literals
           console.log('Social link clicked: ' + platform);
         }
       })();
       ```

    3. **Component-Specific Behavior**:
       - **Carousel**: Auto-rotation timer, pause on hover, keyboard navigation, touch/swipe
       - **Navigation**: Mobile menu toggle, submenu handling, scroll-based sticky behavior
       - **Footer**: Smooth scroll to top, accordion for mobile
       - **Forms**: Real-time validation, AJAX submission, error handling
       - **Cards**: Hover preview, lazy load images, click tracking
       - **Modals**: Focus trap, escape key close, background scroll lock

    4. **Accessibility Features** (WCAG 2.1 AA):
       - Keyboard navigation (Tab, Enter, Escape, Arrow keys)
       - ARIA attribute updates (aria-expanded, aria-selected, aria-hidden)
       - Focus management (focus trap, focus visible)
       - Screen reader announcements (aria-live regions)
       - Skip links and landmark roles

    5. **Performance Optimizations**:
       - Debounce/throttle scroll/resize events
       - IntersectionObserver for lazy loading
       - RequestAnimationFrame for animations
       - Event delegation for dynamic content
       - Passive event listeners where appropriate

    6. **Error Handling & Fallbacks**:
       - Check for required DOM elements before initialization
       - Try-catch blocks for critical operations
       - Console warnings for missing configuration
       - Graceful degradation if features unavailable

    Example ES5-compatible JS structure:
    ```javascript
    (function() {
      'use strict';

      // ES5: Use var, NOT const/let
      var COMPONENT_SELECTOR = '.cmp-footer';

      function init() {
        // ES5: Use var, NOT const
        var components = document.querySelectorAll(COMPONENT_SELECTOR);
        // ES5: Use for loop, NOT forEach
        for (var i = 0; i < components.length; i++) {
          initializeComponent(components[i]);
        }
      }

      function initializeComponent(component) {
        // ES5: Use var, NOT const
        var socialLinks = component.querySelectorAll('.cmp-footer__social-link');
        // ES5: Use for loop, NOT forEach
        for (var i = 0; i < socialLinks.length; i++) {
          socialLinks[i].addEventListener('click', handleSocialClick);
        }
      }

      function handleSocialClick(event) {
        // ES5: String concatenation, NOT template literals
        var platform = event.currentTarget.dataset.platform;
        console.log('Social link clicked: ' + platform);
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
    ```

    VERIFICATION BEFORE WRITING FILE - ES5 Compatibility Check:
    ‚úì No template literals? (Use 'string' + variable, NOT \`string ${variable}\`)
    ‚úì No const/let? (Use var only)
    ‚úì No arrow functions? (Use function() {}, NOT () =>)
    ‚úì No forEach? (Use for loops with index)
    ‚úì No destructuring? (No {x, y} = obj)
    ‚úì No spread operators? (No ...array)
    ‚úì IIFE pattern with 'use strict'?

    Use AEM File Writer tool to write the JS file to the AEM project path.
    Provide: file_path (relative from AEM root), content (JavaScript), aem_project_path (absolute path).

  expected_output: >
    ‚úÖ 6/6 COMPLETE: JavaScript file created at:
    {aem_project_path}/ui.frontend/src/main/webpack/components/_[component-name].js

    üéâ ALL 6 FILES GENERATED IN PROJECT!

    Summary:
    1. Component definition: {aem_project_path}/ui.apps/.../components/[component-name]/.content.xml
    2. HTL template: {aem_project_path}/ui.apps/.../components/[component-name]/[component-name].html
    3. Sling Model: {aem_project_path}/core/.../models/[ComponentName]Model.java
    4. Author dialog: {aem_project_path}/ui.apps/.../components/[component-name]/_cq_dialog/.content.xml
    5. SCSS styles: {aem_project_path}/ui.frontend/.../components/_[component-name].scss
    6. JavaScript: {aem_project_path}/ui.frontend/.../components/_[component-name].js

    ‚úÖ Component ready for verification!
  agent: aem_alchemist
  context:
    - design_analysis_task
    - aem_frontend_scss_generation_task

aem_component_verification_task:
  description: >
    STEP 7 (FINAL): Verify All 6 Component Files Were Created Successfully

    Read JSON: output-visual_strategist/design_analysis.json
    Extract component.name for verification

    CRITICAL: Use AEM Project Path from inputs:
    - AEM Project Path: {aem_project_path}
    - AEM App ID: {aem_app_id}
    - AEM Namespace: {aem_namespace}

    VERIFICATION CHECKLIST - Use DirectoryListTool to check each file exists:

    1. **Component Definition** (.content.xml)
       Path: {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/.content.xml
       Check: File exists and contains jcr:primaryType="cq:Component"

    2. **HTL Template** ([component-name].html)
       Path: {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/[component-name].html
       Check: File exists and contains data-sly-use.model

    3. **Sling Model** ([ComponentName]Model.java)
       Path: {aem_project_path}/core/src/main/java/com/{aem_namespace}/core/models/[ComponentName]Model.java
       Check: File exists and contains @Model annotation

    4. **Author Dialog** (_cq_dialog/.content.xml)
       Path: {aem_project_path}/ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/_cq_dialog/.content.xml
       Check: File exists and contains dialog structure

    5. **SCSS Styles** (_[component-name].scss)
       Path: {aem_project_path}/ui.frontend/src/main/webpack/components/_[component-name].scss
       Check: File exists and contains .cmp-[component-name] class

    6. **JavaScript** (_[component-name].js)
       Path: {aem_project_path}/ui.frontend/src/main/webpack/components/_[component-name].js
       Check: File exists and contains IIFE pattern

    Use DirectoryListTool to list files in each directory and confirm existence.

    For each file:
    - ‚úÖ EXISTS ‚Üí Mark as successful
    - ‚ùå MISSING ‚Üí Report error with exact path

    FINAL REPORT FORMAT:
    ```
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    üéâ COMPONENT GENERATION VERIFICATION REPORT
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    Component Name: [component-name]
    Component Type: [component-type]
    Generated: [timestamp]

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    FILE VERIFICATION (6 files required):
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    [1/6] ‚úÖ Component Definition (.content.xml)
          Location: ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/.content.xml
          Status: EXISTS | Size: [bytes]

    [2/6] ‚úÖ HTL Template ([component-name].html)
          Location: ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/[component-name].html
          Status: EXISTS | Size: [bytes]

    [3/6] ‚úÖ Sling Model ([ComponentName]Model.java)
          Location: core/src/main/java/com/{aem_namespace}/core/models/[ComponentName]Model.java
          Status: EXISTS | Size: [bytes]

    [4/6] ‚úÖ Author Dialog (_cq_dialog/.content.xml)
          Location: ui.apps/src/main/content/jcr_root/apps/{aem_app_id}/components/[component-name]/_cq_dialog/.content.xml
          Status: EXISTS | Size: [bytes]

    [5/6] ‚úÖ SCSS Styles (_[component-name].scss)
          Location: ui.frontend/src/main/webpack/components/_[component-name].scss
          Status: EXISTS | Size: [bytes]

    [6/6] ‚úÖ JavaScript (_[component-name].js)
          Location: ui.frontend/src/main/webpack/components/_[component-name].js
          Status: EXISTS | Size: [bytes]

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    SUMMARY:
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    ‚úÖ Success: 6/6 files created
    ‚ùå Missing: 0/6 files

    STATUS: ‚úÖ COMPONENT GENERATION COMPLETE

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    NEXT STEPS:
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    1. Build the project:
       cd {aem_project_path}
       mvn clean install -PautoInstallPackage

    2. Verify in AEM:
       - Open: http://localhost:4502/editor.html
       - Add component from "MOHH Websites - Content" group
       - Configure and test

    3. Check browser console for any JavaScript errors

    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    ```

    If ANY file is missing, provide exact path and suggest fix.

  expected_output: >
    ‚úÖ VERIFICATION COMPLETE

    Detailed verification report showing:
    - All 6 files checked
    - File sizes
    - Success/failure status
    - Next steps for deployment

    If all files exist ‚Üí Component generation 100% successful!
    If any missing ‚Üí Clear error message with paths
  agent: aem_alchemist
  context:
    - design_analysis_task
    - aem_frontend_js_generation_task

aem_build_deploy_task:
  description: >
    Build the AEM project and deploy the newly created component to the
    local AEM instance.

    STEP 1: NAVIGATE TO AEM PROJECT
    - Change directory to your AEM project path

    STEP 2: RUN MAVEN BUILD
    - Execute: mvn clean install -PautoInstallPackage
    - This will:
      * Compile the Java Sling Model
      * Package the component files
      * Deploy to AEM at http://localhost:4502

    STEP 3: MONITOR BUILD OUTPUT
    - Check for compilation errors in Java code
    - Check for packaging errors
    - Check for deployment success
    - Look for "BUILD SUCCESS" message

    STEP 4: VERIFY DEPLOYMENT
    - Confirm packages were installed
    - Check for any deployment warnings or errors

    STEP 5: REPORT STATUS
    If BUILD SUCCESS:
      - Report successful deployment
      - Provide component path
      - Provide CRXDE link to component

    If BUILD FAILED:
      - Report the error details
      - Suggest fixes based on error type
      - Ask if user wants to retry after fixing

  expected_output: >
    Build and deployment status report:
    - Maven build result (SUCCESS or FAILED)
    - Any errors or warnings encountered
    - Component location in AEM
    - CRXDE link for verification
    - Next steps for testing
  agent: aem_alchemist
  context:
    - aem_component_conversion_task

aem_testing_task:
  description: >
    Guide the user through testing the AEM component and gather feedback.

    STEP 1: PROVIDE TESTING INSTRUCTIONS
    Give the user clear instructions:

    "Please test the component in AEM:

    1. Open AEM Sites Editor:
       http://localhost:4502/editor.html/content/your-app/us/en.html

    2. Add the component to a page:
       - Click '+' to add component
       - Find the component in component browser
       - Drag it onto the page

    3. Test the component dialog:
       - Click the component to select it
       - Click the wrench icon to open dialog
       - Verify all fields are present and editable
       - Fill in some test values
       - Click 'Done'

    4. Verify component rendering:
       - Check if component displays correctly
       - Verify styles are applied
       - Check responsive behavior
       - Test any interactive elements

    5. Preview the page:
       - Click 'Preview' mode
       - Verify component works in preview
    "

    STEP 2: ASK FOR USER CONFIRMATION
    Use AskUserQuestion tool to ask:
    "Did the component work correctly?"

    Options:
    - "Yes, it works perfectly"
    - "No, there are issues"
    - "Partially works, needs fixes"

    STEP 3: IF ISSUES FOUND
    If user reports issues:
    - Ask: "What issues did you encounter?"
    - Get detailed description of problems
    - Analyze the issues
    - Suggest fixes or offer to fix automatically

    STEP 4: IF WORKING CORRECTLY
    If component works:
    - Mark component as completed
    - Ask if user wants to convert another component
    - Return to component selection

  expected_output: >
    Testing report with:
    - Testing instructions provided to user
    - User's feedback on component functionality
    - Status: Working / Has Issues / Needs Fixes
    - If issues: List of problems encountered
    - Next action: Fix issues or move to next component
  agent: aem_alchemist
  context:
    - aem_build_deploy_task
